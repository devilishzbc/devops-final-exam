pipeline {
  agent any

  options {
    timestamps()
    disableConcurrentBuilds()
    skipDefaultCheckout(true)   // убираем лишний автоматический checkout
  }

  environment {
    APP_DIR    = 'app/online-library'
    DOCKERFILE = 'docker/Dockerfile_SabitulyNurmukhammed'
    COMPOSE    = 'docker/docker-compose_SabitulyNurmukhammed.yml'

    // ВАЖНО:
    // GHCR: ghcr.io/<user>/<repo>
    // DockerHub: <user>/<repo>
    IMAGE_REPO = 'ghcr.io/devilishzbc/online-library'

    // ID credentials для логина в registry (usernamePassword)
    // Поменяй на СВОЙ реальный ID из Jenkins Credentials
    REGISTRY_CREDS_ID = 'ghcr-creds'

    // ID credentials для Postgres env (Secret text)
    PG_ENV_CRED_ID = 'pg-env'
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
        script {
          def sha = sh(returnStdout: true, script: 'git rev-parse --short=7 HEAD').trim()
          def b   = (env.BRANCH_NAME ?: 'manual').replaceAll('[^A-Za-z0-9_.-]','-')

          env.IMAGE_TAG = "${b}-${env.BUILD_NUMBER}-${sha}"
          env.APP_IMAGE = "${env.IMAGE_REPO}:${env.IMAGE_TAG}"

          // для GHCR нужен host, для DockerHub пусто
          env.REG_HOST = env.IMAGE_REPO.startsWith('ghcr.io/') ? 'ghcr.io' : ''
        }
      }
    }

    stage('Build') {
      steps {
        dir(env.APP_DIR) {
          sh '''
            set -e
            chmod +x ./gradlew
            ./gradlew --no-daemon clean build
          '''
        }
      }
    }

    stage('Test') {
      steps {
        dir(env.APP_DIR) {
          sh '''
            set -e
            ./gradlew --no-daemon test
          '''
        }
      }
      post {
        always {
          junit allowEmptyResults: true, testResults: "${APP_DIR}/build/test-results/test/*.xml"
        }
      }
    }

    stage('Static Analysis (optional)') {
      steps {
        dir(env.APP_DIR) {
          sh '''
            set -e
            # если в проекте нет checkstyle/spotbugs - просто пропускаем
            if ./gradlew --no-daemon tasks --all | grep -qE "(checkstyleMain|spotbugsMain)"; then
              ./gradlew --no-daemon checkstyleMain spotbugsMain || true
            else
              echo "No Checkstyle/SpotBugs tasks found -> skipping"
            fi
          '''
        }
      }
    }

    stage('Docker Build (dynamic tag)') {
      steps {
        sh '''
          set -e
          docker build -t "$APP_IMAGE" -f "$DOCKERFILE" .
        '''
      }
    }

    stage('Docker Push') {
      steps {
        withCredentials([usernamePassword(
          credentialsId: env.REGISTRY_CREDS_ID,
          usernameVariable: 'REG_USER',
          passwordVariable: 'REG_PASS'
        )]) {
          sh '''
            set -e

            if [ -n "$REG_HOST" ]; then
              echo "$REG_PASS" | docker login "$REG_HOST" -u "$REG_USER" --password-stdin
            else
              echo "$REG_PASS" | docker login -u "$REG_USER" --password-stdin
            fi

            docker push "$APP_IMAGE"

            if [ -n "$REG_HOST" ]; then
              docker logout "$REG_HOST" || true
            else
              docker logout || true
            fi
          '''
        }
      }
    }

    stage('Deploy (main only)') {
      when { branch 'main' }
      steps {
        withCredentials([string(credentialsId: env.PG_ENV_CRED_ID, variable: 'PG_ENV')]) {
          sh '''
            set -e
            cd "$WORKSPACE"

            # 1) создаём docker/.env внутри workspace (и для compose env_file, и для variable substitution)
            mkdir -p docker
            printf "%s\n" "$PG_ENV" > docker/.env

            # 2) деплой (compose подтянет APP_IMAGE и postgres env)
            APP_IMAGE="$APP_IMAGE" docker compose \
              -f "$COMPOSE" \
              --env-file docker/.env \
              up -d --no-build

            # 3) проверки
            docker ps
            curl -fsS http://localhost:8081/actuator/health
          '''
        }
      }
    }
  }

  post {
    always {
      archiveArtifacts allowEmptyArchive: true, artifacts: "${APP_DIR}/build/reports/**"
      echo "DONE: ${env.JOB_NAME} #${env.BUILD_NUMBER} (${env.BRANCH_NAME})"
    }
    failure {
      echo "FAILED: ${env.JOB_NAME}/${env.BRANCH_NAME} #${env.BUILD_NUMBER}"
    }
  }
}
 
